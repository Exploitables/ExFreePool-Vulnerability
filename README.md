# ExFreePool Vulnerability
 My research into taking advantage of ExFreePool primitives.

### Motivation
 A while back, I discovered a zero day vulnerability in an antivirus driver, allowing low-privileged users to free an arbitrary pool chunk via the ExFreePool kernel API. As someone who wants to grasp a firmer understanding of the Windows pool internals, I decided to conduct some of my own research into it. Not to mention, that I find the words "kernel pool" particularly funny, for one reason or another. Probably because it reminds me of a swimming pool. Who knows?
 
### Pool Chunks In User Land!?!?
 From what I understood from the vulnerability I discovered then, I was able to free an arbitrary pool chunk. I decided to perform some Google-Fu, with no articles or papers documenting this kind of exploit primitive. It is an exploit primitive that has never been thought of before. When I remembered my discovery again a couple days ago, I decided to set out and perform some of my own research. As you can see in this repository, I have created a special driver that would allow the user to free an arbitrary pool chunk, without checks to whether or not the chunk resided in user land. I have also created a proof-of-concept to test my theories, which can be found in this repository as well, along with the three fully-reversed pool structures.
 
 Though, here was the draw-back: you do **not** have a primitive to allocate a pool chunk in kernel land. How would I have done this without bug checking the machine, or let alone being able to even attempt freeing the fake pool structure? This is what I sought after achieving.
 
 I am aware we can spray the kernel non-paged pools with objects, such as the Event or Semaphore objects, but we were not able to entirely control the contents of these objects. Specifically, we want to be able to control an entire pool chunk's data, and then redirect execution flow via overwriting the procedure callbacks (e.g. OkayToCloseProcedure). By overwriting this procedure callback pointer with a pointer to our shellcode, we can then begin executing arbitrary code! However, this procedure is called upon freeing the pool chunk. We may not be able to control data in kernel land, but we can definitely control data in user land. And then I realized: "Could I create a carefully crafted pool structure in user-land?" And yes, you can!
 
### The Dive Into The Non-Paged Swimming Pools
 The kernel memory pools are the heap-equivalent to user-land memory, and the non-paged pool memory is memory that will always reside in memory, never paged out into the page file or the disk. We want to be able to re-create the user-mode equivalent to the non-paged memory pool, so I started off by utilizing HeapAlloc to allocate memory onto the process heap, then VirtualLock afterwards to lock the allocated heap memory in memory. Note that I chose an allocation of 4096 (0x1000) bytes to closely resemble an actual pool page.
 ```C
 memory_page = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 4096);
	if (!memory_page)
	{
		printf("\n[-] Failed to allocate 4096 bytes onto the process heap.");
		unused = getchar();
		return 1;
	}
	printf("\n[+] Allocated 4096 bytes onto the process heap. Allocation Address: 0x%p", memory_page);

	if (!VirtualLock(memory_page, 4096))
	{
		printf("\n[-] Failed to lock the page of heap memory. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Locked the page of heap memory.");
 ```
 
 We now have our fake memory page. For those who are not fond of the Windows pool structures, I highly advise you give these provided write-ups a reading before continuing.
 * [Exploit Development: Swimming In The (Kernel) Pool - Leveraging Pool Vulnerabilities From Low-Integrity Exploits, Part 1](https://connormcgarr.github.io/swimming-in-the-kernel-pool-part-1/)
 * [Kernel Pool Exploitation on Windows 7](https://www.exploit-db.com/docs/english/16032-kernel-pool-exploitation-on-windows-7.pdf)
 * [Part 16: Kernel Exploitation -> Pool Overflow](https://www.fuzzysecurity.com/tutorials/expDev/20.html)
 
 With our fake memory page, we want to re-create the entire pool chunk perfectly. As you may have learned, exploiting pool overflow bugs only requires that you overwrite the OkayToCloseProcedure (or an equivalent) pointer. With this overwrite, you did not have to overwrite the entire pool structure, as it would remain entirely valid (assuming the headers prior to the pointer overwrite were valid themselves). However, we are crafting an entire chunk of memory that has **no** pool structures within whatsoever. With this in mind, you would have to rebuild the entire pool structure by hand.
 
 With the snippet below, I used the Fwpp* non-paged pool structures for reference when I initialized the three core pool structures.
 ```C
 void initialize_pool_header(PPOOL_HEADER input_pool_header)
{
	POOL_HEADER pool_header = *input_pool_header;	// dt nt!_POOL_HEADER ffffaa0b73f0dae0

	pool_header.PreviousSize = 0;					// +0x000 PreviousSize     : 0y00000000 (0)
	pool_header.PoolIndex = 0;						// +0x000 PoolIndex        : 0y00000000 (0)
	pool_header.BlockSize = 0x1000;					// +0x002 BlockSize        : 0y00010111 (0x17) (Changed to 0x1000 to match our fake pool allocation)
	pool_header.PoolType = 0x2;						// +0x002 PoolType         : 0y00000010 (0x2)
	pool_header.Ulong1 = 0x2170000;					// +0x000 Ulong1           : 0x2170000
	pool_header.PoolTag = 0x70707746;				// +0x004 PoolTag          : 0x70707746
	pool_header.AllocatorBackTraceIndex = 0x6B5E;	// +0x008 AllocatorBackTraceIndex : 0x6b5e
	pool_header.PoolTagHash = 0x9417;				// +0x00a PoolTagHash      : 0x9417
}

void initialize_object_header_quota(POBJECT_HEADER_QUOTA input_object_header_quota)
{
	OBJECT_HEADER_QUOTA object_header_quota = *input_object_header_quota;  // dt nt!_OBJECT_HEADER_QUOTA_INFO ffffaa0b73f0dae0+8

	object_header_quota.PagedPoolCharge = 0x94176B5E;					   // +0x000 PagedPoolCharge  : 0x94176b5e
	object_header_quota.NonPagedPoolCharge = 0xDE0E839E;				   // +0x004 NonPagedPoolCharge : 0xde0e839e
	object_header_quota.SecurityDescriptorCharge = 0x73F132A0;			   // +0x008 SecurityDescriptorCharge : 0x73f132a0
	object_header_quota.Reserved1 = 0xFFFFAA0B;							   // +0x00c Reserved1        : 0xffffaa0b
	object_header_quota.SecurityDescriptorQuotaBlock = 0xFFFF8407C9848D78; // +0x010 SecurityDescriptorQuotaBlock : 0xffff8407`c9848d78 Void
	object_header_quota.Reserved2 = 0;									   // +0x018 Reserved2        : 0
}

void initialize_object_header(POBJECT_HEADER input_object_header)
{
	OBJECT_HEADER object_header = *input_object_header;						// dt nt!_OBJECT_HEADER ffffaa0b73f0dae0+8+10

	object_header.PointerCount = 0x136305996165768;							// +0x000 PointerCount     : 0n-136305996165768
	object_header.HandleCount = 0;											// +0x008 HandleCount      : 0n0
	object_header.NextToFree = (void*)0;									// +0x008 NextToFree       : (null) 
	object_header.Lock = (void*)0;											// +0x010 Lock             : _EX_PUSH_LOCK
	object_header.TypeIndex = 0;											// +0x018 TypeIndex        : 0 '';
	object_header.TraceFlags = 0;											// +0x019 TraceFlags       : 0 ''
	object_header.DbgRefTrace = 0;											// +0x019 DbgRefTrace      : 0y0
	object_header.DbgTracePermanent = 0;									// +0x019 DbgTracePermanent : 0y0
	object_header.InfoMask = 0;												// +0x01a InfoMask         : 0 ''
	object_header.Flags = 0;												// +0x01b Flags            : 0 ''
	object_header.NewObject = 0;											// +0x01b NewObject        : 0y0
	object_header.KernelObject = 0;											// +0x01b KernelObject     : 0y0
	object_header.KernelOnlyAccess = 0;										// +0x01b KernelOnlyAccess : 0y0
	object_header.ExclusiveObject = 0;										// +0x01b ExclusiveObject  : 0y0
	object_header.PermanentObject = 0;										// +0x01b PermanentObject  : 0y0
	object_header.DefaultSecurityQuota = 0;									// +0x01b DefaultSecurityQuota : 0y0
	object_header.SingleHandleEntry = 0;									// +0x01b SingleHandleEntry : 0y0
	object_header.DeletedInline = 0;										// +0x01b DeletedInline    : 0y0
	object_header.Reserved = 0;												// +0x01c Reserved         : 0
	object_header.ObjectCreateInfo = 0x0100000000000130;					// +0x020 ObjectCreateInfo : 0x01000000`00000130 _OBJECT_CREATE_INFORMATION
	object_header.QuotaBlockCharged = 0x0100000000000130;					// +0x020 QuotaBlockCharged : 0x01000000`00000130 Void
	object_header.SecurityDescriptor = 0x0001001000000130;					// +0x028 SecurityDescriptor : 0x00010010`00000130 Void
	object_header.Body = (void*)0;											// +0x030 Body             : _QUAD
}
 ```
 
 You will find that there were no fully-reversed pool structures for Windows 10 online, that was until now (feel free to use them!), so I had to spend some of my time in WinDbg, dumping out the contents of each structure. These three functions will initialize the structures that we pass through them, so we can begin placing these parts of each structure onto our fake pool allocation.
 
 From what I have learned with my time having fun with the Windows pool internals, is that there are is no padding between each structure in memory, which is evident in [@connormcgarr](https://github.com/connormcgarr)'s write-up and [@FuzzySecurity](https://github.com/FuzzySecurity)'s write-up on the pool overflow vulnerabilities. Now that we have built the entirety of our three core pool structures, it is time to place them onto our heap allocation. Bare in mind that each field in each structure appears in order of how WinDbg interpreted them, which appears to be sufficient.
 ```C
 *memory_page = pool_header.PreviousSize;
	*(memory_page + 4) = pool_header.PoolIndex;
	*(memory_page + 8) = pool_header.BlockSize;
	*(memory_page + 16) = pool_header.PoolType;
	*(memory_page + 20) = pool_header.Ulong1;
	*(memory_page + 24) = pool_header.PoolTag;
	*(memory_page + 28) = pool_header.AllocatorBackTraceIndex;
	*(memory_page + 30) = pool_header.PoolTagHash;
	printf("\n[+] Mapped the fake pool header onto the heap allocation.");

	*(memory_page + 32) = object_header_quota.PagedPoolCharge;
	*(memory_page + 36) = object_header_quota.NonPagedPoolCharge;
	*(memory_page + 40) = object_header_quota.SecurityDescriptorCharge;
	*(memory_page + 44) = object_header_quota.Reserved1;
	*(memory_page + 48) = object_header_quota.SecurityDescriptorQuotaBlock;
	*(memory_page + 52) = object_header_quota.Reserved2;
	printf("\n[+] Mapped the fake object header quota onto the heap allocation.");

	*(memory_page + 56) = object_header.PointerCount;
	*(memory_page + 64) = object_header.HandleCount;
	*(memory_page + 72) = object_header.NextToFree;
	*(memory_page + 80) = object_header.Lock;
	*(memory_page + 81) = object_header.TypeIndex;
	*(memory_page + 82) = object_header.TraceFlags;
	*(memory_page + 84) = object_header.DbgRefTrace;
	*(memory_page + 88) = object_header.DbgTracePermanent;
	*(memory_page + 89) = object_header.InfoMask;
	*(memory_page + 90) = object_header.Flags;
	*(memory_page + 94) = object_header.NewObject;
	*(memory_page + 98) = object_header.KernelObject;
	*(memory_page + 102) = object_header.KernelOnlyAccess;
	*(memory_page + 106) = object_header.ExclusiveObject;
	*(memory_page + 110) = object_header.PermanentObject;
	*(memory_page + 114) = object_header.DefaultSecurityQuota;
	*(memory_page + 118) = object_header.SingleHandleEntry;
	*(memory_page + 122) = object_header.DeletedInline;
	*(memory_page + 126) = object_header.Reserved;
	*(memory_page + 130) = object_header.ObjectCreateInfo;
	*(memory_page + 138) = object_header.QuotaBlockCharged;
	*(memory_page + 146) = object_header.SecurityDescriptor;
	*(memory_page + 152) = object_header.Body;
	printf("\n[+] Mapped the fake object header onto the heap allocation.\n[!] Free'ing the target pool chunk in five seconds...");
 ```
 
 Now that we have our fake pool chunk prepared nicely in our user-land, let's try freeing our allocation!
 ![alt text](https://github.com/Exploitables/ExFreePool-Vulnerability/blob/main/Figure%201.png?raw=true)
 ![alt text](https://github.com/Exploitables/ExFreePool-Vulnerability/blob/main/Figure%202.png?raw=true)
 
 ... it appears that freeing the allocation was a bust. This was where I left off at last night, but I have encountered some scenarios where it would attempt to free the allocation, but fail, throwing a non-bug-checking access violation. I do have suspicion though, that I am simply not locking the allocation fast enough, allowing the system to page it out of memory. I have a lot of research to conduct from here.
